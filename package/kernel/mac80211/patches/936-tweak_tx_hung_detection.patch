--- a/drivers/net/wireless/ath/ath9k/ath9k.h
+++ b/drivers/net/wireless/ath/ath9k/ath9k.h
@@ -166,7 +166,7 @@ struct ath_txq {
 	u32 axq_depth;
 	u32 axq_ampdu_depth;
 	bool stopped;
-	bool axq_tx_inprogress;
+	u8 axq_tx_inprogress;
 	struct list_head axq_acq;
 	struct list_head txq_fifo[ATH_TXFIFO_DEPTH];
 	u8 txq_headidx;
--- a/drivers/net/wireless/ath/ath9k/link.c
+++ b/drivers/net/wireless/ath/ath9k/link.c
@@ -40,12 +40,12 @@ void ath_tx_complete_poll_work(struct wo
 
 		ath_txq_lock(sc, txq);
 		if (txq->axq_depth) {
-			if (txq->axq_tx_inprogress) {
+			if (txq->axq_tx_inprogress > 10) {
 				needreset = true;
 				ath_txq_unlock(sc, txq);
 				break;
 			} else {
-				txq->axq_tx_inprogress = true;
+				txq->axq_tx_inprogress++;
 			}
 		}
 		ath_txq_unlock(sc, txq);
--- a/drivers/net/wireless/ath/ath9k/xmit.c
+++ b/drivers/net/wireless/ath/ath9k/xmit.c
@@ -663,7 +663,7 @@ static void ath_tx_process_buffer(struct
 
 	txok = !(ts->ts_status & ATH9K_TXERR_MASK);
 	flush = !!(ts->ts_status & ATH9K_TX_FLUSH);
-	txq->axq_tx_inprogress = false;
+	txq->axq_tx_inprogress = 0;
 
 	txq->axq_depth--;
 	if (bf_is_ampdu_not_probing(bf))
@@ -1653,7 +1653,7 @@ struct ath_txq *ath_txq_setup(struct ath
 		spin_lock_init(&txq->axq_lock);
 		txq->axq_depth = 0;
 		txq->axq_ampdu_depth = 0;
-		txq->axq_tx_inprogress = false;
+		txq->axq_tx_inprogress = 0;
 		sc->tx.txqsetup |= 1<<axq_qnum;
 
 		txq->txq_headidx = txq->txq_tailidx = 0;
@@ -1754,7 +1754,7 @@ void ath_draintxq(struct ath_softc *sc,
 	}
 
 	txq->axq_link = NULL;
-	txq->axq_tx_inprogress = false;
+	txq->axq_tx_inprogress = 0;
 	ath_drain_txq_list(sc, txq, &txq->axq_q);
 
 	ath_txq_unlock_complete(sc, txq);
